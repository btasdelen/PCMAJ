
MULTIPLIER DATA 3
DUTY_CYCLE_HI EQU 0FAh
DUTY_CYCLE_LO EQU 0CBh
MOT1_FW BIT P0.0
MOT1_BW BIT P0.1
MOT2_FW BIT P0.2
MOT2_BW BIT P0.3
ISX_AXIS BIT 0
IS_FW BIT 1
DONE BIT 2
DATAIN	BIT P2.0
CS	BIT P2.4
IOCLK	BIT P2.1
ADDRESS	BIT P2.2
EOC	BIT P2.3

ADC_PORT EQU P2

ORG 0
LJMP MAIN
;
;
;11 LCD + 6 MOTOR + 5 ADC + 2 MASTER + 1 UP_DOWN + 2 LEFT_RIGHT = 27
;
;
;

ORG 00BH
DUTY_CYCLE_END:
SETB DONE
LJMP CLEAR

ORG 00ABH
MAIN:
SETB CS
CLR IOCLK

MOV IE, #10000010b
MOV TMOD, #00010001b

SETB IS_FW
SETB ISX_AXIS
START:

CLR TR1
MOV TH1, #015h
MOV TL1, #0A0h
SETB TR1

ACALL GET_DATA

CLR A
MOV R0, #50h
CALCULATE:
PUSH A
MOV A, @R0
ANL A, #01
MOV C, ACC.0
POP A
RLC A
INC R0
CJNE R0, #55H, CALCULATE


JZ SKIP_MULTI
MULTI:	
CLR DONE
ACALL LOOP

JNB DONE, $
DEC A

JNZ MULTI
SKIP_MULTI:
JNB TF1, $
CLR TF1
SJMP START
BWX:	JNB ISX_AXIS, BWY	;Check if we will send x axis
JB IS_FW, FWX	;Check if we will turn forward or backwards
SETB MOT1_BW
CLR MOT1_FW
RET
FWX:
SETB MOT1_FW
CLR MOT1_BW
RET

BWY: JB IS_FW, FWY
SETB MOT2_BW
CLR MOT2_FW
RET
FWY:
SETB MOT2_FW
CLR MOT2_BW

RET

CLEAR:
JNB ISX_AXIS, CLEAR_FWY
CLR MOT1_BW
CLR MOT1_FW
SJMP NEXT_CYCLE

CLEAR_FWY:
CLR MOT2_FW
CLR MOT2_BW
SJMP NEXT_CYCLE

NEXT_CYCLE:
CLR TR0
RETI
LOOP:
MOV TH0, #DUTY_CYCLE_HI
MOV TL0, #DUTY_CYCLE_LO
ACALL BWX
SETB TR0
RET
GET_DATA:
MOV R0, #10
MOV R1, #50h
MOV A, #10h	; 0001 channel for x axis

CLR CS
SEND_X:
RLC A
MOV ADDRESS, C

SETB IOCLK

NOP
NOP

CLR IOCLK

DJNZ R0, SEND_X
;END OF ADDRESSING X
SETB CS

JB EOC, $
MOV R0, #10
MOV A, #20h	; 0010 cHAnnel for y axis
JNB EOC, $	; WAIT FOR RISING EDGE OF EOC

CLR CS
TAKE_X_SEND_Y:
RLC A
MOV ADDRESS, C

SETB IOCLK

MOV @R1, ADC_PORT
INC R1

CLR IOCLK

DJNZ R0, TAKE_X_SEND_Y
;END OF TAKING X, ADDRESSING Y
SETB CS

JB EOC, $
MOV R0, #10
JNB EOC, $	; WAIT FOR RISING EDGE OF EOC

CLR CS

TAKE_Y:
NOP
NOP

SETB IOCLK

MOV @R1, ADC_PORT
INC R1

CLR IOCLK

DJNZ R0, TAKE_Y

SETB CS

RET


END

